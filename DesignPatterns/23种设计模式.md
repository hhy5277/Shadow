# 23种设计模式

### 1.单例模式

- 饿汉模式(线程不安全，速度快，浪费资源多)
- 懒汉模式(线程不安全,第一次加载较慢)
- 双重检测(加锁，线程安全，第一次加载较慢)
- 静态方法



### 2.工厂模式

> 定义一个用于创建爱你对象的接口，让子类决定实例化哪一个类，是一个类的实例化延迟到其子类

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601917-1999-DP-Factory.png)



### 3.抽象工厂模式

>提供一个创建乙烯类相关或者相互依赖对象的接口，而无需指定他们具体的类

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601916-7298-DP-AbstractFactory.png)

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601980-8080-P-AbstractFactory-AddFactory.png)

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601917-7462-P-AbstractFactory-AddProduct.png)



### 4.建造者模式

> 使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式



> 解决的问题：
>
> 1. 用户只需要给出指定复杂对象的类型和内容；
> 2. 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)



- **Product（产品角色）：** 一个具体的产品对象 (指出它的部件)

- **Builder（抽象建造者）：** 创建一个Product对象的各个部件指定的抽象接口  (**定义抽象动作，具体实现未知)**

- **ConcreteBuilder（具体建造者）：** 实现抽象接口，构建和装配各个部件  (**定义具体做什么**)

- **Director（指挥者）：** 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，

  一：隔离了客户与对象的生产过程

  二：负责控制产品对象的生产过程。

>模式讲解： 
>
>1. 指挥者（Director）直接和客户（Client）进行需求沟通； 
>2. 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）； 
>3. 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）； 
>4. 各个具体建造者负责进行产品部件的构建； 
>5. 最终构建成具体产品（Product）。


>1. 电脑城老板（Diretor）和小成（Client）进行需求沟通
>2. 了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）
>3. 指挥装机人员（ConcreteBuilder）去构建组件；
>4. 组装成电脑(Product)



### 5.原型模式

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

 **浅拷贝：**使用一个已知实例对新创建实例的成员变量逐个赋值（传递引用，不能复制实例）

**深拷贝：**当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量，还要引用类型的成员变量创建新的实例，并且初始化为形式参数的实例值（对象内部的引用均复制，它是创建一个新的实例，并且复制实例）

![](https://images0.cnblogs.com/blog/381060/201309/10205053-c368741694b842aca314a0690ab0d00d.jpg)

**主要解决：**在运行期建立和删除原型。

**何时使用：** 

1. 如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。
2. 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。 
3. 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便

###### 模式构成

- Prototype：抽象原型类。声明克隆自身的接口。 
- ConcretePrototype：具体原型类。实现克隆的具体操作。
- Client：客户类。让一个原型克隆自身，从而获得一个新的对象。

###### 模式总结

1.  原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。
2. 克隆分为浅克隆和深克隆两种。



### 6.适配者模式

> 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作（直白点就是转接器）

###### 模式构成

1. **Target(目标抽象类)：**目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。
2. **Adapter(适配器类)：**它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配
3. **Adaptee(适配者类)：**适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类包好了客户希望的业务方法



### 7.桥接模式

> 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化

###### 模式构成

1. **实现化（Implementor）角色：**定义实现化角色的接口，供扩展抽象化角色调用。
2. **Abstraction(抽象化对象)：**定义抽象类，并包含一个对实现化对象的引用
3. **扩展抽象化（Refined    Abstraction）角色：**是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
4. **具体实现化（Concrete Implementor）角色：**给出实现化角色接口的具体实现。

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q11512532X54.gif)