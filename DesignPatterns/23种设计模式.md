# 23种设计模式

### 1.单例模式

- 饿汉模式(线程不安全，速度快，浪费资源多)
- 懒汉模式(线程不安全,第一次加载较慢)
- 双重检测(加锁，线程安全，第一次加载较慢)
- 静态方法



### 2.工厂模式

> 定义一个用于创建爱你对象的接口，让子类决定实例化哪一个类，是一个类的实例化延迟到其子类

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601917-1999-DP-Factory.png)



### 3.抽象工厂模式

>提供一个创建乙烯类相关或者相互依赖对象的接口，而无需指定他们具体的类

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601916-7298-DP-AbstractFactory.png)

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601980-8080-P-AbstractFactory-AddFactory.png)

![](http://www.runoob.com/wp-content/uploads/2018/07/1530601917-7462-P-AbstractFactory-AddProduct.png)



### 4.建造者模式

> 使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式



> 解决的问题：
>
> 1. 用户只需要给出指定复杂对象的类型和内容；
> 2. 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)



- **Product（产品角色）：** 一个具体的产品对象 (指出它的部件)

- **Builder（抽象建造者）：** 创建一个Product对象的各个部件指定的抽象接口  (**定义抽象动作，具体实现未知)**

- **ConcreteBuilder（具体建造者）：** 实现抽象接口，构建和装配各个部件  (**定义具体做什么**)

- **Director（指挥者）：** 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，

  一：隔离了客户与对象的生产过程

  二：负责控制产品对象的生产过程。

>模式讲解： 
>
>1. 指挥者（Director）直接和客户（Client）进行需求沟通； 
>2. 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）； 
>3. 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）； 
>4. 各个具体建造者负责进行产品部件的构建； 
>5. 最终构建成具体产品（Product）。


>1. 电脑城老板（Diretor）和小成（Client）进行需求沟通
>2. 了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）
>3. 指挥装机人员（ConcreteBuilder）去构建组件；
>4. 组装成电脑(Product)



### 5.原型模式

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

 **浅拷贝：**使用一个已知实例对新创建实例的成员变量逐个赋值（传递引用，不能复制实例）

**深拷贝：**当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量，还要引用类型的成员变量创建新的实例，并且初始化为形式参数的实例值（对象内部的引用均复制，它是创建一个新的实例，并且复制实例）

![](https://images0.cnblogs.com/blog/381060/201309/10205053-c368741694b842aca314a0690ab0d00d.jpg)

**主要解决：**在运行期建立和删除原型。

**何时使用：** 

1. 如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。
2. 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。 
3. 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便

###### 模式构成

- Prototype：抽象原型类。声明克隆自身的接口。 
- ConcretePrototype：具体原型类。实现克隆的具体操作。
- Client：客户类。让一个原型克隆自身，从而获得一个新的对象。

###### 模式总结

1.  原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。
2. 克隆分为浅克隆和深克隆两种。



### 6.适配者模式

> 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作（直白点就是转接器）

###### 模式构成

1. **Target(目标抽象类)：**目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。
2. **Adapter(适配器类)：**它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配
3. **Adaptee(适配者类)：**适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类包好了客户希望的业务方法



### 7.桥接模式

> 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化

###### 模式构成

1. **实现化（Implementor）角色：**定义实现化角色的接口，供扩展抽象化角色调用。
2. **Abstraction(抽象化对象)：**定义抽象类，并包含一个对实现化对象的引用
3. **扩展抽象化（Refined    Abstraction）角色：**是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
4. **具体实现化（Concrete Implementor）角色：**给出实现化角色接口的具体实现。

![](http://c.biancheng.net/uploads/allimg/181115/3-1Q11512532X54.gif)



### 8.组合模式

> 又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次

###### 模式构成

1. **Component（抽象构件）：**它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
2. **Leaf（叶子构件）：**它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。
3. **Composite（容器构件）：**表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。



### 9.装饰器模式

> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活(继承关系的替代方案)

- **主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
- **何时使用：**在不想增加很多子类的情况下扩展类。
- **如何解决：**将具体功能职责划分，同时继承装饰者模式。



###### 模式构成

- 抽象构件角色 (给出一个抽象接口，一规范接收附加责任的对象)
- 具体构件角色 (定义一个将要接受附加责任的类)
- 装饰角色 (持有一个构件对象的实例，并定义一个与抽象构件接               口一致的接口)
- 具体装饰角色 (负责给构件对象贴上附加的责任)



### 10.外观模式

> 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口



- **意图：**为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- **主要解决：**降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
- **何时使用：** 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口



###### 模式构成

- 接口
- 接口实现类(实现不同的方法)
- 外观类 xxMarker (使用实体类来代表用户对这些类的调用)



### 11.代理模式

> 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。	



###### 模式总结

- **意图：**为其他对象提供一种代理以控制对这个对象的访问。
- **主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
- **何时使用：**想在访问一个类时做一些控制。
- **如何解决：**增加中间层。

- **应用实例：** 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。



######  模式构成

- 接口类
- 接口实现
- 接口代理类(直接调用接口代理类，实现对象操作)